package com.noxception.midisense.interpreter;

import com.noxception.midisense.api.InterpreterApi;
import com.noxception.midisense.interpreter.exceptions.InvalidDesignatorException;
import com.noxception.midisense.interpreter.exceptions.InvalidUploadException;
import com.noxception.midisense.interpreter.rrobjects.ProcessFileRequest;
import com.noxception.midisense.interpreter.rrobjects.ProcessFileResponse;
import com.noxception.midisense.interpreter.rrobjects.UploadFileRequest;
import com.noxception.midisense.interpreter.rrobjects.UploadFileResponse;
import com.noxception.midisense.models.InterpreterProcessFileRequest;
import com.noxception.midisense.models.InterpreterProcessFileResponse;
import com.noxception.midisense.models.InterpreterUploadFileResponse;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.DependsOn;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.UUID;

/**
 * Class that invokes Interpreter service methods by interpreting requests made to endpoints outlined
 * by the InterpreterAPI interface, a service layer framework generated by Swagger 2.0.
 *
 * This class handles mapping between service layer request and response bodies, and business layer service request
 * and response objects. Any errors that are encountered by the service during method calls are interpreted
 * and dealt with here.
 *
 * For a detailed description of the controller interface, see {@link InterpreterApi} for the definition
 * generated from the openAPI specification application.yaml.
 *
 * For a detailed description of the controller endpoints, please visit http://host:port/swagger-ui.html#/
 * when the Spring application is running.
 *
 *  * @author Adrian Rae
 *  * @author Claudio Teixeira
 *  * @author Hendro Smit
 *  * @author Mbuso Shakoane
 *  * @author Rearabetswe Maeko
 *  * @since 1.0.0
 */

@Slf4j
@CrossOrigin("*")
@RestController
@DependsOn({"configurationLoader"})
public class InterpreterController implements InterpreterApi {

    private final InterpreterServiceImpl interpreterService;

    @Autowired
    public InterpreterController(InterpreterServiceImpl interpreterService) {
        this.interpreterService = interpreterService;
    }

    /** Method that invokes the process method of the Interpreter service and presents the resultant metadata of
     * the work with a specific designator.
     *
     * @param body the request body as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a tuple of the appropriate http status code and response object:
     * Possible valid tuples are a 200 status code and an object that is not null corresponding to
     * a successful request, or a 400 status code and a null object corresponding to a malformed request field.
     */

    @Override
    public ResponseEntity<InterpreterProcessFileResponse> processFile(InterpreterProcessFileRequest body) {

        InterpreterProcessFileResponse responseObject = new InterpreterProcessFileResponse();
        HttpStatus returnStatus = HttpStatus.OK;

        try{
            //pass file designator into request object
            UUID fileDesignator = UUID.fromString(body.getFileDesignator());

            ProcessFileRequest req = new ProcessFileRequest(fileDesignator);

            //Log the call for request
            log.info(String.format("Request | To: %s | For: %s | Assigned: %s","processFile",fileDesignator,req.getDesignator()));

            ProcessFileResponse res = interpreterService.processFile(req);

            //set response status
            responseObject.setMessage(res.getMessage());
            responseObject.setSuccess(res.getSuccess());
            returnStatus = res.getSuccess()?HttpStatus.OK:HttpStatus.BAD_REQUEST;

        }
        catch (InvalidDesignatorException | IllegalArgumentException e) {

            //Log the error
            log.warn(String.format("FAILURE | To: %s | Because: %s ","processFile",e.getMessage()));

            returnStatus = HttpStatus.BAD_REQUEST;
            responseObject.setSuccess(false);
            responseObject.setMessage(e.getMessage());

        }
        //return response object
        return new ResponseEntity<>(responseObject,returnStatus);
    }


    /** Method that invokes the uploadFile method of the Interpreter service and allows for the uploading of the midi
     * file to the system
     *
     * @param file the request file as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a tuple of the appropriate http status code and response object:
     * Possible valid tuples are a 200 status code and an object that is not null corresponding to
     * a successful request, or a 400 status code and a null object corresponding to a malformed request field.
     */
    @Override
    public ResponseEntity<InterpreterUploadFileResponse> uploadFile(MultipartFile file) {
        InterpreterUploadFileResponse responseObject = new InterpreterUploadFileResponse();
        HttpStatus returnStatus = HttpStatus.OK;

        try{

            byte[] fileContents = file.getBytes();

            UploadFileRequest req = new UploadFileRequest(fileContents);

            //Log the call for request
            log.info(String.format("Request | To: %s | For: %s | Assigned: %s","uploadFile",file.getName(),req.getDesignator()));

            UploadFileResponse res = interpreterService.uploadFile(req);

            responseObject.setFileDesignator(res.getFileDesignator().toString());
            responseObject.setSuccess(true);
            responseObject.setMessage("Successfully uploaded file");

        }
        catch (IllegalArgumentException | InvalidUploadException | IOException e) {

            //Log the error
            log.warn(String.format("FAILURE | To: %s | Because: %s ","uploadFile",e.getMessage()));

            returnStatus = HttpStatus.BAD_REQUEST;
            responseObject.setSuccess(false);
            responseObject.setMessage(e.getMessage());

        }

        return new ResponseEntity<>(responseObject,returnStatus);
    }


//    @RequestMapping(
//            value="/interpreter/uploadFile",
//            method= RequestMethod.POST,
//            consumes = MediaType.MULTIPART_FORM_DATA_VALUE
//    )
//    public ResponseEntity<InterpreterUploadFileResponse> uploadFile(@RequestParam("file") MultipartFile file) {
//
//        InterpreterUploadFileResponse responseObject = new InterpreterUploadFileResponse();
//        HttpStatus returnStatus = HttpStatus.OK;
//
//        try{
//
//            byte[] fileContents = file.getBytes();
//
//            UploadFileRequest req = new UploadFileRequest(fileContents);
//
//            //Log the call for request
//            log.info(String.format("Request | To: %s | For: %s | Assigned: %s","uploadFile",file.getName(),req.getDesignator()));
//
//            UploadFileResponse res = interpreterService.uploadFile(req);
//
//            responseObject.setFileDesignator(res.getFileDesignator().toString());
//            responseObject.setSuccess(true);
//            responseObject.setMessage("Successfully uploaded file");
//
//        }
//        catch (IllegalArgumentException | InvalidUploadException | IOException e) {
//
//            //Log the error
//            log.warn(String.format("FAILURE | To: %s | Because: %s ","uploadFile",e.getMessage()));
//
//            returnStatus = HttpStatus.BAD_REQUEST;
//            responseObject.setSuccess(false);
//            responseObject.setMessage(e.getMessage());
//
//        }
//
//        return new ResponseEntity<>(responseObject,returnStatus);
//
//    }

    //================================
    // HELPER METHODS
    //================================


    /** Method that invokes the intArrayToByteArray method of the Interpreter service and allows for the conversion
     * from an int array to a byte array
     *
     * @param list the request list as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a byte array representation of the given list
     */
    private byte[] intArrayToByteArray(List<Integer> list)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(baos);
        for (int element : list) {
            try {
                out.writeUTF(Integer.toString(element));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return baos.toByteArray();
    }

}
