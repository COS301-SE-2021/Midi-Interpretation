package com.noxception.midisense.interpreter;

import com.noxception.midisense.api.DisplayApi;
import com.noxception.midisense.api.InterpreterApi;
import com.noxception.midisense.config.MIDISenseConfig;
import com.noxception.midisense.interpreter.exceptions.InvalidDesignatorException;
import com.noxception.midisense.interpreter.exceptions.InvalidUploadException;
import com.noxception.midisense.interpreter.rrobjects.ProcessFileRequest;
import com.noxception.midisense.interpreter.rrobjects.ProcessFileResponse;
import com.noxception.midisense.interpreter.rrobjects.UploadFileRequest;
import com.noxception.midisense.interpreter.rrobjects.UploadFileResponse;
import com.noxception.midisense.models.InterpreterProcessFileRequest;
import com.noxception.midisense.models.InterpreterProcessFileResponse;
import com.noxception.midisense.models.InterpreterUploadFileResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.UUID;

/**
 * Class that invokes Interpreter service methods by interpreting requests made to endpoints outlined
 * by the InterpreterAPI interface, a service layer framework generated by Swagger 2.0.
 *
 * This class handles mapping between service layer request and response bodies, and business layer service request
 * and response objects. Any errors that are encountered by the service during method calls are interpreted
 * and dealt with here.
 *
 * For a detailed description of the controller interface, see {@link InterpreterApi} for the definition
 * generated from the openAPI specification application.yaml.
 *
 * For a detailed description of the controller endpoints, please visit http://host:port/swagger-ui.html#/
 * when the Spring application is running.
 *
 *  * @author Adrian Rae
 *  * @author Claudio Teixeira
 *  * @author Hendro Smit
 *  * @author Mbuso Shakoane
 *  * @author Rearabetswe Maeko
 *  * @since 1.0.0
 */

@CrossOrigin("*")
@RestController
public class InterpreterController implements InterpreterApi {

    @Autowired
    InterpreterServiceImpl interpreterService;

    /** Method that invokes the process method of the Interpreter service and presents the resultant metadata of
     * the work with a specific designator.
     *
     * @param body the request body as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a tuple of the appropriate http status code and response object:
     * Possible valid tuples are a 200 status code and an object that is not null corresponding to
     * a successful request, or a 400 status code and a null object corresponding to a malformed request field.
     */

    @Override
    public ResponseEntity<InterpreterProcessFileResponse> processFile(InterpreterProcessFileRequest body) {

        InterpreterProcessFileResponse responseObject = new InterpreterProcessFileResponse();
        HttpStatus returnStatus = HttpStatus.OK;

        try{

            UUID fileDesignator = UUID.fromString(body.getFileDesignator());

            ProcessFileRequest req = new ProcessFileRequest(fileDesignator);
            ProcessFileResponse res = interpreterService.processFile(req);

            responseObject.setMessage(res.getMessage());
            responseObject.setSuccess(res.getSuccess());

        }
        catch (InvalidDesignatorException | IllegalArgumentException e) {

            returnStatus = HttpStatus.BAD_REQUEST;
            responseObject = null;

        }

        return new ResponseEntity<>(responseObject,returnStatus);
    }

    /** Method that invokes the uploadFile method of the Interpreter service and allows for the uploading of the midi
     * file to the system
     *
     * @param file the request file as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a tuple of the appropriate http status code and response object:
     * Possible valid tuples are a 200 status code and an object that is not null corresponding to
     * a successful request, or a 400 status code and a null object corresponding to a malformed request field.
     */
    @RequestMapping(
            value="/interpreter/uploadFile",
            method= RequestMethod.POST,
            consumes = MediaType.MULTIPART_FORM_DATA_VALUE
    )
    public ResponseEntity<InterpreterUploadFileResponse> uploadFile(@RequestParam("file") MultipartFile file) {

        InterpreterUploadFileResponse responseObject = new InterpreterUploadFileResponse();
        HttpStatus returnStatus = HttpStatus.OK;

        try{

            byte[] fileContents = file.getBytes();

            UploadFileRequest req = new UploadFileRequest(fileContents);
            UploadFileResponse res = interpreterService.uploadFile(req);

            responseObject.setFileDesignator(res.getFileDesignator().toString());

        }
        catch (IllegalArgumentException | InvalidUploadException | IOException e) {

            returnStatus = HttpStatus.BAD_REQUEST;
            responseObject = null;

        }

        return new ResponseEntity<>(responseObject,returnStatus);

    }

    //================================
    // HELPER METHODS
    //================================


    /** Method that invokes the intArrayToByteArray method of the Interpreter service and allows for the conversion
     * from an int array to a byte array
     *
     * @param list the request list as interpreted by the service layer framework. See {@link InterpreterApi}
     * @return a byte array representation of the given list
     */
    private byte[] intArrayToByteArray(List<Integer> list)
    {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(baos);
        for (int element : list) {
            try {
                out.writeUTF(Integer.toString(element));
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return baos.toByteArray();
    }

}
